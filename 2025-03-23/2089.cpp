#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <math.h>
#include <cmath>

using namespace std;

/*
	*문제 번호 : 2089

	*문제명 : -2진수

	*문제 설명 :
		  -2진법은 부호 없는 2진수로 표현이 된다. 2진법에서는 20, 21, 22, 23이 표현 되지만 -2진법에서는 (-2)0 = 1, (-2)1 = -2, (-2)2 = 4, (-2)3 = -8을 표현한다. 10진수로 1부터 표현하자면 1, 110, 111, 100, 101, 11010, 11011, 11000, 11001 등이다.

		  10진법의 수를 입력 받아서 -2진수를 출력하는 프로그램을 작성하시오.

	*입력 :
		  첫 줄에 10진법으로 표현된 수 N이 주어진다.

	*출력 :
		  -2진법 수를 출력한다.

*/
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);


	//* n이 양심적인 크기로 들어왔음.
	int n;
	cin >> n;

	string binary = "";


	//* 1. -2진법은 수열에 -2를 나누면 앞의 항이 무엇인지 알 수 있다. n은 규칙을 가진 수열이다. 
	//* 그렇다면 -2/를 나눈 후 나머지를 구한다. n의 각 항이 존재하는지 존재하지 않는 지 확인한다.
	//* 나머지가 0인 경우는 신경 쓸 필요없다. /-2를 곱해도 0이다.
	//* 정리에 따르면 나머지는 0 <= m <= |r| 이다. m은 항상 양수여야 한다. 음수가 나오는 경우 r을 강제로 더해서 양수로 만든다.
	// => 좀 더 직관적인 증명이 없을까?
	// => n이 음수라면 mod도 음수가 나온다. => 양수인 경우 뒤의 자리를 버려가면서 문제 없이 연산이 되지만, 음수인 경우에는 

	while (abs(n) > 0) {
		int mod = n % -2;

		if (mod == 0) {
			n /= -2;
			binary += "0";
			continue;
		}

		if (n < 0) {
			n /= -2;
			//* n++을 해주는 이유는 음수일 때에는 반드시 mod가 -1이 나오기 때문이다.
			//* 우리는 /-2를 해서 (-2)^0에 값이 존재하는지 존재하지 않는 지를 알고 싶어한다.
			//* 하지만 나머지가 -1이므로 나머지가 1이 되기 위해서는 n/=-2가 아닌, (n-2)/=-2를 해줘야한다.
			//* 다른 관점에서 n = (n/-2) + mod 는 반드시 성립한다. 그런데 mod가 -1이므로 식에 -2를 추가해줘야하고, 따라서 n이 1증가한다.
			n++;

			binary += "1";
			continue;
		} else {

			n /= -2;
			binary += "1";
			continue;
		}
	}

	reverse(binary.begin(), binary.end());

	if (binary.size() == 0) {
		binary = "0";
	}

	cout << binary;

}