#include <bits/stdc++.h>

using namespace std;

long long dp[91][2];

int main() {
	int n;
	cin >> n;

	//이친수는 0으로 시작하지 않는다.
	// 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.
	// 예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.

	// 0과 1중에서 하나를 고른다. 그러나 제약 조건이 있다.
	// 계단 문제랑 유사함.

	// N은 기본적으로 (N-1)*2임. N-1도 (N-2)*2와 유사함.
	// 하지만 N-1이 0인 경우에만 (N-1) * 2를 할 수 있음. 

	// N이 0일때 가질 수 있는 경우의 수. [N][0] = [N-1][0] + [N-1][1]; 
	// [N][1] = [N-1][0];

	dp[1][0] = 1;
	dp[1][1] = 1;

	for (int i = 2;i <= n;i++) {
		dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
		dp[i][1] = dp[i - 1][0];
	}

	cout << dp[n][1];


}